# -*- coding: utf-8 -*-
"""MNIST.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BT1hpM0cyKVxEyuhNmHdmFdpGVOWgS4K

# 손글씨 숫자 인식
- 데이터셋 불러오기
"""

import sys, os
sys.path.append(os.pardir)
from tensorflow.keras.datasets import mnist

(x_train, y_train), (x_test, y_test) = mnist.load_data()

print(x_train.shape)
print(y_train.shape)
print(x_test.shape)
print(y_test.shape)

"""- 이미지로 보이기"""

import matplotlib.pyplot as plt
from tensorflow.keras.datasets import mnist

# 데이터셋 로드
(x_train, y_train), (x_test, y_test) = mnist.load_data()

# 이미지와 라벨 불러오기
img = x_train[0]
label = y_train[0]
print("Label:", label)

# 이미지 출력
plt.imshow(img, cmap='gray')
plt.title(f"Label: {label}")
plt.axis('off')  # 축을 표시하지 않음
plt.show()

"""## 3.6.2 신경망의 추론 처리

"""

def softmax(a):
  c = np.max(a) # a 수열 값 중 가장 큰 값
  exp_a = np.exp(a - c)
  sum_exp_a = np.sum(exp_a)
  return exp_a / sum_exp_a

def sigmoid(x):
    x = np.clip(x, -709, 709)  # 시그모이드 입력값을 제한
    return 1 / (1 + np.exp(-x))

X = np.arange(-5.0, 5.0, 0.1)
Y = sigmoid(X)
plt.plot(X, Y)
plt.ylim(-0.1, 1.1)
plt.show()

import pickle
def get_data():
  (x_train, y_train), (x_test, y_test) = mnist.load_data()
  return x_test, y_test

def init_network():
  with open("/content/sample_data/sample_weight.pkl", 'rb') as f:
    network = pickle.load(f)

  return network

def predict(network, x):
  W1, W2, W3 = network['W1'], network['W2'], network['W3']
  b1, b2, b3 = network['b1'], network['b2'], network['b3']

  a1 = np.dot(x, W1) + b1
  z1 = sigmoid(a1)
  a2 = np.dot(z1, W2) + b2
  z2 = sigmoid(a2)
  a3 = np.dot(z2, W3) + b3
  y = softmax(a3)

  return y

x, t = get_data()
network = init_network()
accuracy_cnt = 0
for i in range(len(x)):
  x_i = x[i].reshape(784)
  y = predict(network, x_i)
  p = np.argmax(y)
  if p == t[i]:
    accuracy_cnt += 1

print("Acccuracy:" + str(float(accuracy_cnt)/ len(x)))

"""## 3.6.3 배치 처리"""

def relu(x):
    return np.maximum(0, x)

x, t = get_data()
network = init_network()

batch_size = 100 # 배치 크기
accuracy_cnt = 0

for i in range(0, len(x), batch_size):
    x_batch = x[i:i+batch_size].reshape(batch_size, 784)
    y_batch = predict(network, x_batch)
    p = np.argmax(y_batch, axis=1)
    accuracy_cnt += np.sum(p == t[i:i+batch_size])

print("Accuracy:" + str(float(accuracy_cnt) / len(x)))